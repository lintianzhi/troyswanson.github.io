---

layout: post

---

It's come to my attention that I am slightly out of date when it comes to some of the more advanced topics of object oriented programming. This post is meant as a study guide for some of these topics.

## Class Abstraction

An abstract class is basically a blueprint for creating another class. Abstract classes cannot be instantiated, but instead must be extended by another class. An abstract class can define properties and methods that will come with the new class that extends it, and can also define abstract properties and methods that the developer must define within the extending class.

Abstract classes should be designed to be filled in by extending classes. A simple example would be an abstract class `Human` that has an abstract property `gender`, with extending classes `Male` and `Female` that automatically set the `gender` property from the abstract class.

## Object Interfaces

An interface looks a lot like an abstract class, and the two can be easily confused because the basic idea is the same. They both provide a blueprint for other classes to extend upon, but an interface is more strict.

The idea of an interface is to provide a *contract* for an extending class to create methods that implement the methods defined in the interface. An interface is usually used to describe a protocol that an implementing class must follow.

## Closures

A closure is a function that references a variable outside of its local scope that would have normally been removed from memory after its encapsulating function has exited.

For example, if the function `foo` is defined inside the function `bar`, and references the variable `x` that was also defined inside `bar`, and the `foo` function is returned by `bar` back into the global scope, then the variable `x` is considered to be closed around the context of `foo`. This creates a closure which prevents `x` from being destroyed when `bar` exits, and allows `foo` to be run in the global scope while still referencing `x`.

{% highlight javascript %}

function bar(num) {
  var x = num;
  function foo() {
    return x * 2;
  }
  return foo;
}

var y = bar(5)();
var z = bar(7)();

alert(z); // 14
alert(y); // 10

{% endhighlight %}

This snippet demonstrates the behavior described above, but also illustrates the idea that, since functions are so portable in JavaScript, you can execute the function that is returned by another function immediately, and then store the value that it returns into another variable. The exercise of executing a function that is returned by another function is referred to as an Immediately Invoked Function Expression.
